<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>20Q Multiplayer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; background: linear-gradient(135deg,#f9fafb,#e5e7eb); color:#111; }
    .container { max-width: 900px; margin: 0 auto; padding: 16px; }
    h1 { text-align:center; margin:16px 0; }
    .card { background:white; border-radius:12px; padding:16px; margin:12px 0; box-shadow:0 2px 6px rgba(0,0,0,0.1); }
    .row { display:flex; gap:8px; margin:8px 0; flex-wrap:wrap; align-items:center; }
    input, button { padding:8px 12px; border-radius:8px; border:1px solid #ccc; font-size:14px; }
    button { background:#2563eb; color:white; border:none; cursor:pointer; transition:background 0.2s; }
    button:hover { background:#1e40af; }
    .pill { padding:2px 8px; border-radius:999px; background:#f3f4f6; }
    .log, .chat-box { border:1px solid #ddd; border-radius:8px; padding:12px; height:200px; overflow:auto; background:#fafafa; }
    .progress { height:20px; border-radius:8px; overflow:hidden; background:#e5e7eb; margin-top:8px; }
    .progress-bar { height:100%; background:#2563eb; width:0%; transition:width 0.3s; }
    .hidden { display:none !important; }
    #overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); display:none; justify-content:center; align-items:center; z-index:1000; color:white; text-align:center; padding:20px; }
    #overlay .content { background:#111; padding:24px; border-radius:12px; max-width:500px; }
    #overlay h2 { margin-bottom:8px; }
    #overlay p { margin-bottom:12px; color:#ddd; }
    #overlay button { margin:4px; font-size:16px; padding:10px 14px; }
    /* Overlay fine partita */
    #endOverlay { position:fixed; top:0; left:0; right:0; bottom:0; display:none; justify-content:center; align-items:center; background:rgba(0,0,0,0.85); z-index:2000; color:white; text-align:center; padding:20px; }
    #endOverlay .content { padding:24px; border-radius:16px; animation:pop 0.6s ease; max-width:520px; }
    #endOverlay.win .content { background:linear-gradient(135deg,#16a34a,#4ade80); }
    #endOverlay.lose .content { background:linear-gradient(135deg,#dc2626,#f87171); }
    #endOverlay h2 { font-size:28px; margin-bottom:8px; }
    #endOverlay p { margin:0; }
    @keyframes pop { from { transform:scale(0.7); opacity:0; } to { transform:scale(1); opacity:1; } }
    /* Timer */
    #turnTimer { height:18px; border-radius:8px; background:#e5e7eb; overflow:hidden; margin-top:8px; display:none; }
    #turnTimer .bar { height:100%; background:#2563eb; width:100%; transition:width linear; }
    #turnTimerLabel { font-size:14px; margin-top:6px; text-align:center; display:none; color:#374151; }
    /* secret disabled look */
    input[disabled] { background:#e5e7eb; color:#6b7280; cursor:not-allowed; }
    /* status */
    #status { font-size:13px; color:#374151; margin-left:8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>20Q Multiplayer</h1>

    <!-- HOME -->
    <div id="home" class="card">
      <div class="row">
        <input id="name" placeholder="Il tuo nome" />
        <input id="code" placeholder="Codice stanza (es. ABCD)" />
        <button id="create">Crea (Pensatore)</button>
        <span id="status">Connessione: <span id="statusText">‚Äî</span></span>
      </div>
      <h3>Stanze attive</h3>
      <div id="rooms"><i>Nessuna stanza attiva al momento.</i></div>
    </div>

    <!-- GAME -->
    <div id="game" class="card hidden">
      <div class="row">
        <button id="leave">‚¨ÖÔ∏è Esci</button>
        <span class="pill">Turno: <span id="turn">‚Äì</span></span>
        <span class="pill">Domande: <span id="qcount">0</span>/<span id="qmax">20</span></span>
      </div>

      <div class="progress"><div class="progress-bar" id="progress"></div></div>

      <div id="thinker" class="row hidden">
        <input id="secret" placeholder="Parola segreta" />
        <button id="start">Avvia round</button>
      </div>

      <div id="actions" class="row">
        <input id="question" placeholder="Fai una domanda s√¨/no" />
        <button id="ask">Chiedi</button>
        <input id="guess" placeholder="Tenta la risposta" />
        <button id="submitGuess">Indovina</button>
      </div>

      <!-- Timer -->
      <div id="turnTimer"><div class="bar" id="turnTimerBar"></div></div>
      <div id="turnTimerLabel"></div>

      <h3>Log</h3>
      <div class="log" id="log"></div>

      <h3>Chat</h3>
      <div class="chat-box" id="chat"></div>
      <div class="row">
        <input id="chatInput" placeholder="Scrivi un messaggio..." style="flex:1;" />
        <button id="sendChat">Invia</button>
      </div>
    </div>
  </div>

  <!-- Overlay per il pensatore -->
  <div id="overlay">
    <div class="content">
      <h2 id="overlay-question">Domanda</h2>
      <p id="overlay-secret"></p>
      <div>
        <button id="ansYes">S√¨</button>
        <button id="ansNo">No</button>
        <button id="ansIDK">Non so</button>
      </div>
    </div>
  </div>

  <!-- Overlay fine partita -->
  <div id="endOverlay">
    <div class="content" id="endContent">
      <h2 id="endTitle"></h2>
      <p id="endMessage"></p>
      <div style="margin-top:12px;">
        <button onclick="document.getElementById('endOverlay').style.display='none'">Chiudi</button>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    /* Robust, complete client (v1.3) - derived from v1.2 */
    const socket = io();
    let roomCode = null;
    let me = { id: null, name: null, role: null };
    let lastQuestionId = null;
    let timerHideTimeout = null;
    const $ = id => document.getElementById(id);

    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',\"'\":'&#39;'}[c])); }

    /* UI helpers */
    function appendLog(msg) {
      const d = document.createElement('div'); d.textContent = msg;
      $('log').appendChild(d); $('log').scrollTop = $('log').scrollHeight;
    }
    function appendChat(name, text) {
      const d = document.createElement('div'); d.innerHTML = '<b>'+escapeHtml(name)+':</b> '+escapeHtml(text);
      $('chat').appendChild(d); $('chat').scrollTop = $('chat').scrollHeight;
    }
    function setStatus(text, color) {
      $('statusText').textContent = text;
      if (color) $('statusText').style.color = color; else $('statusText').style.color = '#374151';
      console.log('[status]', text);
    }

    /* Timer UI */
    function startTurnTimer(durationMs, type) {
      clearTurnTimerUI();
      $('turnTimer').style.display = 'block';
      $('turnTimerLabel').style.display = 'block';
      $('turnTimerBar').style.transition = 'none';
      $('turnTimerBar').style.width = '100%';
      setTimeout(() => {
        $('turnTimerBar').style.transition = `width ${durationMs}ms linear`;
        $('turnTimerBar').style.width = '0%';
      }, 50);
      $('turnTimerLabel').textContent = (type === 'ask') ? 'Hai 60 secondi per fare la domanda...' : (type === 'answer' ? 'Sei il Pensatore: 60s per rispondere...' : 'Tentativo bonus: 60s per indovinare...');
      timerHideTimeout = setTimeout(() => clearTurnTimerUI(), durationMs);
    }
    function clearTurnTimerUI() {
      if (timerHideTimeout) { clearTimeout(timerHideTimeout); timerHideTimeout = null; }
      $('turnTimerBar').style.transition = 'none';
      $('turnTimerBar').style.width = '100%';
      $('turnTimer').style.display = 'none';
      $('turnTimerLabel').style.display = 'none';
    }
    function stopTurnTimer() { clearTurnTimerUI(); }

    /* End overlay */
    function showEndOverlay(title, sub, win) {
      $('endTitle').textContent = title;
      $('endMessage').textContent = sub;
      const el = $('endOverlay');
      el.className = win ? 'win' : 'lose';
      el.style.display = 'flex';
    }

    /* Overlay answer */
    function sendAnswer(ans) {
      if (!lastQuestionId || !roomCode) return;
      socket.emit('question:answer', { code: roomCode, id: lastQuestionId, answer: ans });
      lastQuestionId = null;
      $('overlay').style.display = 'none';
      stopTurnTimer();
    }

    /* Event listeners for overlay buttons */
    $('ansYes').onclick = () => sendAnswer('S√¨');
    $('ansNo').onclick = () => sendAnswer('No');
    $('ansIDK').onclick = () => sendAnswer('Non so');

    /* Home actions (create/join) */
    $('create').addEventListener('click', () => {
      me.name = $('name').value || 'Anon';
      roomCode = ($('code').value || 'ABCD').toUpperCase();
      if (!socket || !socket.connected) {
        setStatus('Connessione assente ‚Äî riconnettendo...', 'orange');
      } else {
        setStatus('Creazione stanza ' + roomCode + '...', 'blue');
      }
      console.log('emit room:create', { code: roomCode, name: me.name });
      socket.emit('room:create', { code: roomCode, name: me.name });
    });

    // leave
    $('leave').addEventListener('click', () => {
      if (!roomCode) return;
      socket.emit('room:leave', { code: roomCode });
      roomCode = null;
      me.role = null;
      $('game').classList.add('hidden');
      $('home').classList.remove('hidden');
      $('log').innerHTML = '';
      $('chat').innerHTML = '';
      stopTurnTimer();
    });

    /* Gameplay actions */
    $('start').addEventListener('click', () => socket.emit('round:start', { code: roomCode, secretWord: $('secret').value || '' }));
    $('ask').addEventListener('click', () => {
      const t = $('question').value.trim();
      if (t) { socket.emit('question:ask', { code: roomCode, text: t }); $('question').value = ''; stopTurnTimer(); }
    });
    $('submitGuess').addEventListener('click', () => {
      const t = $('guess').value.trim();
      if (t) { socket.emit('guess:submit', { code: roomCode, text: t }); $('guess').value = ''; stopTurnTimer(); }
    });
    $('sendChat').addEventListener('click', () => {
      const text = $('chatInput').value.trim();
      if (text) { socket.emit('chat:message', { code: roomCode, name: me.name, text }); $('chatInput').value = ''; }
    });

    /* Socket handlers */
    socket.on('connect', () => {
      me.id = socket.id;
      setStatus('Connesso', 'green');
      console.log('socket connected', socket.id);
      socket.emit('rooms:list');
    });
    socket.on('disconnect', () => {
      setStatus('Disconnesso', 'red');
      console.log('socket disconnected');
      stopTurnTimer();
    });
    socket.on('connect_error', (err) => {
      setStatus('Errore connessione', 'red');
      console.error('connect_error', err);
    });

    // update room list
    socket.on('rooms:update', (list) => {
      const el = $('rooms');
      el.innerHTML = '';
      if (!list || list.length === 0) {
        el.innerHTML = '<i>Nessuna stanza attiva al momento.</i>';
        return;
      }
      list.forEach(r => {
        const div = document.createElement('div');
        div.className = 'row';
        div.innerHTML = `<span>Stanza <b>${escapeHtml(r.code)}</b> ‚Äî Giocatori: ${r.players} ‚Äî Stato: ${escapeHtml(r.status)}</span>`;
        const btn = document.createElement('button');
        btn.textContent = 'Entra';
        btn.addEventListener('click', () => {
          me.name = $('name').value || 'Anon';
          roomCode = r.code;
          setStatus('Richiesta join ' + roomCode + '...', 'blue');
          socket.emit('room:join', { code: roomCode, name: me.name });
        });
        div.appendChild(btn);
        el.appendChild(div);
      });
    });

    socket.on('system:error', (m) => { appendLog('‚ùó ' + m); setStatus('Errore: ' + m, 'red'); console.warn('system:error', m); });

    socket.on('room:state', (s) => {
      // show game UI
      $('home').classList.add('hidden');
      $('game').classList.remove('hidden');
      $('qmax').textContent = s.maxQuestions;
      const meEntry = s.players.find(p => p.id === me.id);
      if (meEntry) me.role = meEntry.role;
      $('thinker').classList.toggle('hidden', me.role !== 'thinker');
      $('actions').classList.toggle('hidden', me.role === 'thinker');
      $('start').classList.toggle('hidden', s.status !== 'waiting');
      // disable secret when not waiting
      const secretInput = $('secret');
      if (secretInput) secretInput.disabled = (s.status !== 'waiting');
      appendLog(`üë• Stanza ${s.code} ‚Äî giocatori: ${s.players.map(p=>p.name + (p.role==='thinker'?'(P)':'')).join(', ')}`);
      setStatus('Nella stanza ' + s.code, 'black');
    });

    socket.on('log:history', (msgs) => { msgs.forEach(m => appendLog(m)); });
    socket.on('log:message', (m) => appendLog(m));
    socket.on('chat:history', (msgs) => { msgs.forEach(m => appendChat(m.name, m.text)); });
    socket.on('chat:message', ({ name, text }) => appendChat(name, text));

    socket.on('round:started', ({ maxQuestions, players }) => {
      $('qcount').textContent = 0;
      $('progress').style.width = '0%';
      appendLog('‚ñ∂Ô∏è Round iniziato! Max ' + maxQuestions + ' domande.');
      $('start').classList.add('hidden');
    });
    socket.on('round:secret', ({ secretWord }) => appendLog('üîí Sei Pensatore. Parola: ' + secretWord));

    socket.on('question:new', (q) => {
      appendLog(`‚ùì (${q.byName}) ${q.text}`);
      if (me.role === 'thinker') {
        lastQuestionId = q.id;
        $('overlay-question').textContent = q.text;
        $('overlay-secret').textContent = 'Parola: ' + ($('secret').value || '(segreta)');
        $('overlay').style.display = 'flex';
      }
    });
    socket.on('question:update', (q) => {
      appendLog(`üó£Ô∏è Risposta: ${q.answer}`);
      stopTurnTimer();
      if (me.role === 'thinker') $('overlay').style.display = 'none';
    });

    socket.on('turn:now', ({ socketId, name }) => {
      $('turn').textContent = socketId === me.id ? 'TU' : (name || '‚Äì');
    });

    socket.on('guess:new', (g) => {
      appendLog(`üéØ ${g.name} ha tentato: "${g.text}" ${g.correct ? '‚úÖ' : '‚ùå'}`);
      stopTurnTimer();
    });

    socket.on('counter:update', ({ asked, max }) => {
      $('qcount').textContent = asked;
      $('progress').style.width = (asked/max*100)+'%';
    });

    // Timer: server tells exactly when to start timer UI for a given player
    socket.on('timer:start', ({ duration, type }) => {
      startTurnTimer(duration, type);
    });

    socket.on('round:ended', ({ message, secretWord, winnerId }) => {
      appendLog('üèÅ ' + message + (secretWord ? ` (Parola: ${secretWord})` : ''));
      $('start').classList.remove('hidden');
      stopTurnTimer();

      // Determine win/lose
      let isWin = false;
      if (winnerId) isWin = (winnerId === me.id);
      else isWin = (me.role === 'thinker'); // fallback
      const title = isWin ? 'üéâ Hai vinto!' : 'üíÄ Hai perso';
      const sub = message + (secretWord ? ` Parola: ${secretWord}` : '');
      showEndOverlay(title, sub, isWin);
    });

    /* Utility UI for debugging / feedback */
    function showEndOverlay(title, sub, win) {
      $('endTitle').textContent = title;
      $('endMessage').textContent = sub;
      const el = $('endOverlay');
      el.className = win ? 'win' : 'lose';
      el.style.display = 'flex';
    }
  </script>
</body>
</html>
